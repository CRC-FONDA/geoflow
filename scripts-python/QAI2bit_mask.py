#! /usr/bin/python3

import argparse
from typing import Dict, Optional, List
import gdal
import numpy as np

parser = argparse.ArgumentParser(
	prog="QAI flags to bit mask",
	description="This script takes a FORCE-generated QAI image together with a user selection of quality bits/quality level as defined by FORCE.\n"
				"Just like FORCE, this program also accepts individual flags specified by their 'names' as "
				"per https://force-eo.readthedocs.io/en/latest/howto/qai.html#quality-bits-in-force\n"
				"It outputs a bitmask (0/1) GTiff which can be used further down the processing pipeline."
)
parser.add_argument("-qf", "--qai_file", nargs=1, type=str, required=True, help="Path to QAI file generated by FORCE.")
parser.add_argument("-of", "--out_file", nargs=1, type=str, required=True, help="Output path for binary Mask.")
# TODO
#  validate input and allow for 'better than' option (e.g. at least medium illumination conditions or better)?????????
parser.add_argument("-qb", "--qai_bits", action="extend", nargs="+", type=str, required=True, metavar="quality-flag",
					help="List of quality flags which should be set. A set flag indicates, that all pixels with said bit set are masked in the output image "
						 "and consequently considered as no data. The list follows the FORCE convention. If a flag is omitted from the list, "
						 "it will be ignored and thus, either one of all possible values with respect for the flag are considered valid data. "
						 "WARNING: Currently, there is no input validation for conflicting flags and it's only possible to filter for exact matches "
						 "(e.g. it is not possible to filter pixels, which are at least mediocre illuminated)")

args: Dict[str, str] = {key: (value[0] if isinstance(value, List) and key != "qai_bits" else value) for key, value in vars(parser.parse_args()).items()}


def generate_masking_bits(flag_selection: List[str]) -> Dict[str, np.int16]:
	# @formatter:off
	masking_dict: Dict[str, np.int16] = {
		"NODATA":				np.int16(0b0000000000000001),
		"CLOUD_BUFF":			np.int16(0b0000000000000010),
		"CLOUD_OPAQUE":			np.int16(0b0000000000000100),
		"CLOUD_CIRRUS":			np.int16(0b0000000000000110),
		"CLOUD_SHADOW":			np.int16(0b0000000000001000),
		"SNOW":					np.int16(0b0000000000010000),
		"WATER":				np.int16(0b0000000000100000),
		"AEROSOL_INTERPOLATED":	np.int16(0b0000000001000000),
		"AEROSOL_HIGH":			np.int16(0b0000000010000000),
		"AEROSOL_FILL":			np.int16(0b0000000011000000),
		"SUBZERO":				np.int16(0b0000000100000000),
		"SATURATION":			np.int16(0b0000001000000000),
		"HIGH_ZENITH":			np.int16(0b0000010000000000),
		"ILLUMINATION_MEDIUM":	np.int16(0b0000100000000000),
		"ILLUMINATION_POOR":	np.int16(0b0001000000000000),
		"ILLUMINATION_SHADOW":	np.int16(0b0001100000000000),
		"SLOPE":				np.int16(0b0010000000000000),
		"WATER_VAPOR":			np.int16(0b0100000000000000),
		"EMPTY":				np.int16(0b0000000000000000)
	}
	# @formatter:on

	return {key: value for key, value in masking_dict.items() if key in flag_selection}


def read_raster(path: str) -> gdal.Dataset:
	if raster := gdal.Open(path, gdal.GA_ReadOnly):
		return raster
	raise OSError(f"Failed to open dataset {path}")


def write_raster(template_raster: gdal.Dataset, out_path: str, data: np.array) -> int:
	driver: gdal.Driver = gdal.GetDriverByName("GTiff")
	out_raster: Optional[gdal.Dataset] = driver.Create(out_path, template_raster.RasterXSize, template_raster.RasterYSize, 1, gdal.GDT_Byte,
													   ["COMPRESS=LZW", "NBITS=1",  # "TILED=YES", "PREDICTOR=2",
														# f"BLOCKXSIZE={template_raster.RasterXSize}", f"BLOCKYSIZE={int(template_raster.RasterYSize / 10)}"
														])
	if not out_raster:
		return 1

	# copy GeoTransform and SpatialRef to new dataset
	out_raster.SetGeoTransform(template_raster.GetGeoTransform())
	out_raster.SetProjection(template_raster.GetSpatialRef().ExportToWkt())

	out_band: gdal.Band = out_raster.GetRasterBand(1)
	out_band.WriteArray(data)

	out_raster = None

	return 0


def main():
	user_selected_flags = generate_masking_bits(args.get("qai_bits"))

	qai_raster: gdal.Dataset = read_raster(args.get("qai_file"))
	qai_array: np.ndarray = qai_raster.ReadAsArray(0, 0, qai_raster.RasterXSize, qai_raster.RasterYSize)

	compound_flag: np.int16 = np.int16(0b0000000000000000)
	for bit_field in user_selected_flags.values():
		compound_flag = np.bitwise_or(compound_flag, bit_field)

	qai_array = np.bitwise_and(qai_array, compound_flag, dtype=np.int16)

	# if not a single flag matched, the cell is zero and thus valid. To convey this a little more clearly, the array is inverted.
	qai_mask: np.ndarray = np.invert(np.where(qai_array != 0, 1, qai_array).astype(np.byte)) + 2

	if write_raster(qai_raster, args.get("out_file"), qai_mask):
		raise OSError(f"Failed to write output dataset {args.get('out_file')}")

	qai_raster = None


if __name__ == "__main__":
	main()
